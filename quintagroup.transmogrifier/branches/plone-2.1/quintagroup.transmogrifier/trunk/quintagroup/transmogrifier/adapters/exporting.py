from xml.dom import minidom

from zope.interface import implements
from zope.component import adapts

from OFS.Image import File

from Products.Archetypes import atapi
from Products.Archetypes.interfaces import IBaseObject
from Products.ATContentTypes.interface import IATTopicCriterion
from Products.Marshall.registry import getComponent
from Products.Archetypes import config as atcfg

from quintagroup.transmogrifier.interfaces import IExportDataCorrector

class ReferenceExporter(object):
    """ Add reference fields to XML, generated by Marshall product.
    """
    implements(IExportDataCorrector)
    adapts(IBaseObject)

    def __init__(self, context):
        self.context = context

    def __call__(self, data):
        data['data'] = self.exportReferences(data['data'])
        return data

    def exportReferences(self, xml):
        """ Marshall 1.0.0 doesn't export references, do it manually.
        """
        doc = minidom.parseString(xml)
        root = doc.documentElement
        for fname in self.context.Schema().keys():
            if not isinstance(self.context.Schema()[fname], atapi.ReferenceField):
                continue
            elem = doc.createElement("field")
            attr = doc.createAttribute("name")
            attr.value = fname
            elem.setAttributeNode(attr)
            for value in self.context[fname]:
                ref = doc.createElement('reference')
                uid = doc.createElement('uid')
                value = doc.createTextNode(str(value))
                uid.appendChild(value)
                ref.appendChild(uid)
                elem.appendChild(ref)
            root.appendChild(elem)
        return doc.toxml('utf-8')

class FileExporter(ReferenceExporter):
    """ Add file fields to XML, generated by Marshall product.
    """
    implements(IExportDataCorrector)

    def __call__(self, data):
        xml = data['data']
        xml = self.normalizeBinaryField(xml)
        data['data'] = self.exportReferences(xml)
        return data

    def normalizeBinaryField(self, data):
        """ Rewrite 'image' or 'file' xml element data with binary data.

            'data' - xml text, formed by Marshall. It's basestring and can have non-ascii characters,
            but minidom.parseString(data) returns unicode string and we need to explicitly set
            encoding when returning modified xml data (if not and there non-ascii characters in
            data, UnicodeDecodeError is raised when calling doc.toxml()).
        """
        data, tagName = self.repairXMLData(data)
        if tagName is None:
            # return unchanged data 
            return data
        doc = minidom.parseString(data)
        root = doc.documentElement
        # there is only one 'field' element with name attribute that is equal to 'file' or 'image'
        elem = [field for field in root.getElementsByTagName('field') 
                     if field.getAttribute('name') == tagName][0]

        field = self.context[tagName]
        # create 'filename' attribute (decode file name to unicode using utf-8 encoding)
        attr = doc.createAttribute('filename')
        attr.value = field.getFilename() #.decode('utf-8')
        elem.setAttributeNode(attr)
        # create 'content_type' attribute
        attr = doc.createAttribute('content_type')
        attr.value = field.getContentType()
        elem.setAttributeNode(attr)
        # create 'transfer_encoding' attribute
        attr = doc.createAttribute('transfer_encoding')
        attr.value = 'base64'
        elem.setAttributeNode(attr)

        # get file data and encode it in CDATA section
        value = field.data
        if isinstance(value, File):
            value = getattr(value, 'data', value)
        value = str(value).encode('base64')
        value = doc.createCDATASection(value)
        # remove old childs and add new
        if elem.hasChildNodes():
            for i in elem.childNodes:
                elem.removeChild(i)
        elem.appendChild(value)
        elem.normalize()
        return doc.toxml('utf-8')

    def repairXMLData(self, data):
        """ Find element with binary data, remove invalid data and remove element's name.
            This element is 'file' or 'image'.
        """
        tagName = None
        if data.find('<field name="file">') != -1:
            tagName = 'file'
        elif data.find('<field name="image">') != -1:
            tagName = 'image'
        else:
            return data, tagName
        openTag = '<field name="%s">' % tagName
        closeTag = '</field>'
        index1 = data.find(openTag) + len(openTag)
        index2 = data.find(closeTag, index1)
        out = data[:index1] + data[index2:]
        return out, tagName

class CriterionExporter(ReferenceExporter):
    """ Special marshalling adapter for topic criterias.
    """

    implements(IExportDataCorrector)
    adapts(IATTopicCriterion)

    def __init__(self, context):
        self.context = context
        self.marshaller = getComponent('atxml')

    def __call__(self, data):
        if data['data'] is not None:
            return super(CriterionExporter, self).__call__(data)
        # Marshall fails when object has UID that is equal to None
        # fix it here by setting it to empty string and after marshalling setting back to old value
        old_uid_attr = getattr(self.context, atcfg.UUID_ATTR)
        setattr(self.context, atcfg.UUID_ATTR, "")

        ct, length, xml = self.marshaller.marshall(self.context)
        xml = self.exportReferences(xml)
        data['data'] = xml

        setattr(self.context, atcfg.UUID_ATTR, old_uid_attr)
        return data
